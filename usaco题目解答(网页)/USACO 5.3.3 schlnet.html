<html>
<head>
  <title>USACO 5.3.3 schlnet</title>
  <basefont face="Tahoma" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/268868 (zh-CN); Windows/6.1.7601 Service Pack 1;"/>
  <style>
    body, td {
      font-family: Tahoma;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1824"/>
<h1>USACO 5.3.3 schlnet</h1>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div align="left" style="text-align: -webkit-left; text-indent: 0mm; margin: 4.75mm 0mm;"><font face="黑体"><font color="#010101"><span style="font-size: 13pt;"><b>[</b></span></font><font color="#010101"><span style="font-size: 13pt;"><b>解题报告</b></span></font><font color="#010101"><span style="font-size: 13pt;"><b>]</b></span></font></font></div><div align="left" style="text-align: -webkit-left; text-indent: 0mm; margin: 4.75mm 0mm;"><div align="left" style="text-indent: 0mm; margin: 4.75mm 0mm;"><font color="#010101" face="宋体" size="4">首先分析题目大意，简言之就是你要找出整张图的SCC,第一问是给最少多少个学校发送软件可以使其他学校也得到软件。解决方案是求出SCC后，我们可以利用缩图的结果，找到所有入度为0的点，这些点肯定要的得到软件。其他的结点只要不是入度为0就都可以得到，因为SCC是拓扑的。这样第一问就解决了，用到的SCC算法是Tarjan算法。时间复杂度O(M+N)。</font></div><div align="left" style="text-indent: 0mm; margin: 4.75mm 0mm;"><font color="#010101" face="宋体" size="4">第二问的要求是最少添加多少条有向边可以使得整张图任意一个学校有软件，其他的就能得到。也就是我们至少添加多少边可以令目前的缩图强连通。考虑SCC是拓扑的，那么每一对入度和出度为0的不同的点之间添加一条边使其成环即可让其融入缩图之中，那么当这些点对都处理完时，要么整张图都缩成一个点，要么剩余一些只剩出度或者入度的点，对于这些剩余点只要让其他强连通分量任意引出一个互补的边就可以使其也同样成为一个缩点。因此最小需要<b>MAX(出度为0，入度为0)</b>个边。有一个特殊情况，如果SCC本身就是一个点，就不需要其他额外的边。</font></div></div><div align="left" style="text-align: -webkit-left; text-indent: 0mm; margin: 4.75mm 0mm;"><font face="黑体"><font color="#010101"><span style="font-size: 13pt;"><b>[</b></span></font><font color="#010101"><span style="font-size: 13pt;"><b>运行情况</b></span></font><font color="#010101"><span style="font-size: 13pt;"><b>]</b></span></font></font></div><div align="left" style="text-align: -webkit-left; text-indent: 0mm; margin: 4.75mm 0mm;"><div><pre style="text-align: start;">
Compiling...
Compile: OK

Executing...
   Test 1: TEST OK [0.000 secs, 4028 KB]
   Test 2: TEST OK [0.000 secs, 4028 KB]
   Test 3: TEST OK [0.000 secs, 4028 KB]
   Test 4: TEST OK [0.000 secs, 4028 KB]
   Test 5: TEST OK [0.000 secs, 4028 KB]
   Test 6: TEST OK [0.000 secs, 4028 KB]
   Test 7: TEST OK [0.000 secs, 4028 KB]
   Test 8: TEST OK [0.000 secs, 4028 KB]
   Test 9: TEST OK [0.000 secs, 4028 KB]
   Test 10: TEST OK [0.000 secs, 4028 KB]
   Test 11: TEST OK [0.000 secs, 4028 KB]

All tests OK.
<br>Your program ('schlnet') produced all correct answers!  This is your
submission #6 for this problem.  <b>Congratulations!</b></pre></div></div><div align="left" style="text-align: -webkit-left; text-indent: 0mm; margin: 4.75mm 0mm;"><font face="黑体"><font color="#010101"><span style="font-size: 13pt;"><b>[</b></span></font><font color="#010101"><span style="font-size: 13pt;"><b>程序清单</b></span></font><font color="#010101"><span style="font-size: 13pt;"><b>]</b></span></font></font></div><div align="left" style="text-align: -webkit-left; text-indent: 0mm; margin: 4.75mm 0mm;"><div align="left"><pre style="line-height: 12pt; font-size: 13px; background-color: rgb(255, 255, 236);"></pre><div dir="ltr" lang="zh-cn" style="direction: ltr; text-align: start; font-family: Verdana, Arial, sans-serif;"><div dir="ltr" style="text-align: left;"><div style="font-family: monospace;"><pre style="line-height: 12pt;"></pre><div><pre style="font-size: 13px; line-height: 12pt; background-color: rgb(255, 255, 236);"><span style="color: rgb(51, 153, 0);">#include &lt;iostream&gt;
</span><span style="color: rgb(51, 153, 0);">#include &lt;stack&gt;
</span><span style="color: rgb(51, 153, 0);">#include &lt;string&gt;
</span><span style="line-height: 12pt; text-indent: 0mm; color: rgb(51, 153, 0);">#include &lt;cstdio&gt;
</span><span style="line-height: 12pt; text-indent: 0mm; color: rgb(51, 153, 0);">#include &lt;cstring&gt;
</span><span style="line-height: 12pt; text-indent: 0mm; color: rgb(51, 153, 0);">#include &lt;climits&gt;</span></pre><pre style="font-size: 13px; line-height: 12pt; background-color: rgb(255, 255, 236);"><span style="color: rgb(51, 153, 0);">#define MIN(a, b) (a &lt; b ? a : b)
</span><span style="color: rgb(51, 153, 0);">#define MAX(a, b) (a &gt; b ? a : b)</span>
 
<span style="color: rgb(0, 0, 255);">using</span> <span style="color: rgb(0, 0, 255);">namespace</span> std<span style="color: rgb(0, 128, 128);">;</span>
 
<span style="color: rgb(0, 0, 255);">const</span> <span style="color: rgb(0, 0, 255);">long</span> MAXN <span style="color: rgb(0, 0, 128);">=</span> <span style="color: rgb(0, 0, 221);">205</span><span style="color: rgb(0, 128, 128);">;</span> <span style="color: rgb(102, 102, 102);">//最大节点数目
</span><span style="color: rgb(0, 0, 255);">struct</span> edge<span style="color: rgb(0, 128, 0);">{</span>  <span style="color: rgb(102, 102, 102);">//使用边表存储</span>
    <span style="color: rgb(0, 0, 255);">int</span> x,y<span style="color: rgb(0, 128, 128);">;</span> <span style="color: rgb(102, 102, 102);">//边的两边分别是x,y</span>
    edge <span style="color: rgb(0, 0, 64);">*</span>next<span style="color: rgb(0, 128, 128);">;</span> <span style="color: rgb(102, 102, 102);">//以x为表头的邻接边</span>
    edge<span style="color: rgb(0, 128, 0);">(</span><span style="color: rgb(0, 128, 0);">)</span><span style="color: rgb(0, 128, 0);">{</span><span style="color: rgb(0, 128, 0);">}</span> <span style="color: rgb(102, 102, 102);">//缺省构造函数</span>
    edge<span style="color: rgb(0, 128, 0);">(</span><span style="color: rgb(0, 0, 255);">int</span> x,<span style="color: rgb(0, 0, 255);">int</span> y,edge <span style="color: rgb(0, 0, 64);">*</span>n<span style="color: rgb(0, 128, 0);">)</span><span style="color: rgb(0, 128, 128);">:</span>x<span style="color: rgb(0, 128, 0);">(</span>x<span style="color: rgb(0, 128, 0);">)</span>,y<span style="color: rgb(0, 128, 0);">(</span>y<span style="color: rgb(0, 128, 0);">)</span>,next<span style="color: rgb(0, 128, 0);">(</span>n<span style="color: rgb(0, 128, 0);">)</span><span style="color: rgb(0, 128, 0);">{</span><span style="color: rgb(0, 128, 0);">}</span> <span style="color: rgb(102, 102, 102);">//自定义构造函数</span>
    <span style="color: rgb(0, 0, 255);">void</span> <span style="color: rgb(0, 0, 64);">*</span> operator <span style="color: rgb(0, 0, 221);">new</span> <span style="color: rgb(0, 128, 0);">(</span><span style="color: rgb(0, 0, 255);">size_t</span>,<span style="color: rgb(0, 0, 255);">void</span> <span style="color: rgb(0, 0, 64);">*</span>ptr<span style="color: rgb(0, 128, 0);">)</span><span style="color: rgb(0, 128, 0);">{</span><span style="color: rgb(0, 0, 255);">return</span> ptr<span style="color: rgb(0, 128, 128);">;</span><span style="color: rgb(0, 128, 0);">}</span> <span style="color: rgb(102, 102, 102);">//重载new运算符
</span><span style="color: rgb(0, 128, 0);">}</span><span style="color: rgb(0, 0, 64);">*</span>EDGE<span style="color: rgb(0, 128, 0);">[</span>MAXN <span style="color: rgb(0, 0, 64);">*</span> MAXN<span style="color: rgb(0, 128, 0);">]</span>, <span style="color: rgb(0, 0, 64);">*</span>tempedge <span style="color: rgb(0, 0, 128);">=</span> <span style="color: rgb(0, 0, 221);">new</span> edge<span style="color: rgb(0, 128, 0);">[</span>MAXN <span style="color: rgb(0, 0, 64);">*</span> MAXN<span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 128, 128);">;
</span><span style="color: rgb(0, 0, 255);">int</span> n, m, DFN<span style="color: rgb(0, 128, 0);">[</span>MAXN<span style="color: rgb(0, 128, 0);">]</span>, LOW<span style="color: rgb(0, 128, 0);">[</span>MAXN<span style="color: rgb(0, 128, 0);">]</span>, instack<span style="color: rgb(0, 128, 0);">[</span>MAXN<span style="color: rgb(0, 128, 0);">]</span>, SCC<span style="color: rgb(0, 128, 0);">[</span>MAXN<span style="color: rgb(0, 128, 0);">]</span>, Dindex, count, dgr<span style="color: rgb(0, 128, 0);">[</span>MAXN<span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 128, 0);">[</span><span style="color: rgb(0, 0, 221);">2</span><span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 128, 128);">;</span>
stack<span style="color: rgb(0, 0, 128);">&lt;</span><span style="color: rgb(0, 0, 255);">int</span><span style="color: rgb(0, 0, 128);">&gt;</span> Stack<span style="color: rgb(0, 128, 128);">;</span>
 
<span style="color: rgb(0, 0, 255);">void</span> tarjan<span style="color: rgb(0, 128, 0);">(</span><span style="color: rgb(0, 0, 255);">int</span> n<span style="color: rgb(0, 128, 0);">)</span><span style="color: rgb(0, 128, 0);">{</span>
        DFN<span style="color: rgb(0, 128, 0);">[</span>n<span style="color: rgb(0, 128, 0);">]</span> <span style="color: rgb(0, 0, 128);">=</span> LOW<span style="color: rgb(0, 128, 0);">[</span>n<span style="color: rgb(0, 128, 0);">]</span> <span style="color: rgb(0, 0, 128);">=</span> <span style="color: rgb(0, 0, 64);">++</span>Dindex<span style="color: rgb(0, 128, 128);">;</span>
        instack<span style="color: rgb(0, 128, 0);">[</span>n<span style="color: rgb(0, 128, 0);">]</span> <span style="color: rgb(0, 0, 128);">=</span> <span style="color: rgb(0, 0, 255);">true</span><span style="color: rgb(0, 128, 128);">;</span>
        Stack.<span style="color: rgb(0, 119, 136);">push</span><span style="color: rgb(0, 128, 0);">(</span>n<span style="color: rgb(0, 128, 0);">)</span><span style="color: rgb(0, 128, 128);">;</span>
        <span style="color: rgb(0, 0, 255);">int</span> v<span style="color: rgb(0, 128, 128);">;</span>
        <span style="color: rgb(0, 0, 255);">for</span><span style="color: rgb(0, 128, 0);">(</span>edge <span style="color: rgb(0, 0, 64);">*</span>e <span style="color: rgb(0, 0, 128);">=</span> EDGE<span style="color: rgb(0, 128, 0);">[</span>n<span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 128, 128);">;</span> e<span style="color: rgb(0, 128, 128);">;</span> e <span style="color: rgb(0, 0, 128);">=</span> e<span style="color: rgb(0, 0, 64);">-</span><span style="color: rgb(0, 0, 128);">&gt;</span>next<span style="color: rgb(0, 128, 0);">)</span><span style="color: rgb(0, 128, 0);">{</span>
                v <span style="color: rgb(0, 0, 128);">=</span> e<span style="color: rgb(0, 0, 64);">-</span><span style="color: rgb(0, 0, 128);">&gt;</span>y<span style="color: rgb(0, 128, 128);">;</span>
                <span style="color: rgb(0, 0, 255);">if</span><span style="color: rgb(0, 128, 0);">(</span><span style="color: rgb(0, 0, 64);">!</span>DFN<span style="color: rgb(0, 128, 0);">[</span>v<span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 128, 0);">)</span><span style="color: rgb(0, 128, 0);">{</span>
                        tarjan<span style="color: rgb(0, 128, 0);">(</span>v<span style="color: rgb(0, 128, 0);">)</span><span style="color: rgb(0, 128, 128);">;</span>
                        LOW<span style="color: rgb(0, 128, 0);">[</span>n<span style="color: rgb(0, 128, 0);">]</span> <span style="color: rgb(0, 0, 128);">=</span> MIN<span style="color: rgb(0, 128, 0);">(</span>LOW<span style="color: rgb(0, 128, 0);">[</span>n<span style="color: rgb(0, 128, 0);">]</span>, LOW<span style="color: rgb(0, 128, 0);">[</span>v<span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 128, 0);">)</span><span style="color: rgb(0, 128, 128);">;</span>
                <span style="color: rgb(0, 128, 0);">}</span><span style="color: rgb(0, 0, 255);">else</span> <span style="color: rgb(0, 0, 255);">if</span><span style="color: rgb(0, 128, 0);">(</span>instack<span style="color: rgb(0, 128, 0);">[</span>v<span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 128, 0);">)</span>
                        LOW<span style="color: rgb(0, 128, 0);">[</span>n<span style="color: rgb(0, 128, 0);">]</span> <span style="color: rgb(0, 0, 128);">=</span> MIN<span style="color: rgb(0, 128, 0);">(</span>LOW<span style="color: rgb(0, 128, 0);">[</span>n<span style="color: rgb(0, 128, 0);">]</span>, DFN<span style="color: rgb(0, 128, 0);">[</span>v<span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 128, 0);">)</span><span style="color: rgb(0, 128, 128);">;</span>
        <span style="color: rgb(0, 128, 0);">}</span>
        <span style="color: rgb(0, 0, 255);">if</span><span style="color: rgb(0, 128, 0);">(</span>DFN<span style="color: rgb(0, 128, 0);">[</span>n<span style="color: rgb(0, 128, 0);">]</span> <span style="color: rgb(0, 0, 128);">==</span> LOW<span style="color: rgb(0, 128, 0);">[</span>n<span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 128, 0);">)</span><span style="color: rgb(0, 128, 0);">{</span>
                count<span style="color: rgb(0, 0, 64);">++</span><span style="color: rgb(0, 128, 128);">;</span>
                <span style="color: rgb(0, 0, 255);">do</span><span style="color: rgb(0, 128, 0);">{</span>
                        instack<span style="color: rgb(0, 128, 0);">[</span>v <span style="color: rgb(0, 0, 128);">=</span> Stack.<span style="color: rgb(0, 119, 136);">top</span><span style="color: rgb(0, 128, 0);">(</span><span style="color: rgb(0, 128, 0);">)</span><span style="color: rgb(0, 128, 0);">]</span> <span style="color: rgb(0, 0, 128);">=</span> <span style="color: rgb(0, 0, 255);">false</span><span style="color: rgb(0, 128, 128);">;</span>
                        Stack.<span style="color: rgb(0, 119, 136);">pop</span><span style="color: rgb(0, 128, 0);">(</span><span style="color: rgb(0, 128, 0);">)</span><span style="color: rgb(0, 128, 128);">;</span>
                        SCC<span style="color: rgb(0, 128, 0);">[</span>v<span style="color: rgb(0, 128, 0);">]</span> <span style="color: rgb(0, 0, 128);">=</span> count<span style="color: rgb(0, 128, 128);">;</span>
                <span style="color: rgb(0, 128, 0);">}</span><span style="color: rgb(0, 0, 255);">while</span><span style="color: rgb(0, 128, 0);">(</span>v <span style="color: rgb(0, 0, 64);">!</span><span style="color: rgb(0, 0, 128);">=</span> n<span style="color: rgb(0, 128, 0);">)</span><span style="color: rgb(0, 128, 128);">;</span>
 
        <span style="color: rgb(0, 128, 0);">}
</span><span style="color: rgb(0, 128, 0);">}</span>
 
<span style="color: rgb(0, 0, 255);">int</span> main<span style="color: rgb(0, 128, 0);">(</span><span style="color: rgb(0, 128, 0);">)</span><span style="color: rgb(0, 128, 0);">{</span>
        <span style="color: rgb(0, 0, 221);">freopen</span><span style="color: rgb(0, 128, 0);">(</span><span style="color: rgb(255, 0, 0);">&quot;schlnet.in&quot;</span>, <span style="color: rgb(255, 0, 0);">&quot;r&quot;</span>, <span style="color: rgb(0, 0, 255);">stdin</span><span style="color: rgb(0, 128, 0);">)</span><span style="color: rgb(0, 128, 128);">;</span>
        <span style="color: rgb(0, 0, 221);">freopen</span><span style="color: rgb(0, 128, 0);">(</span><span style="color: rgb(255, 0, 0);">&quot;schlnet.out&quot;</span>, <span style="color: rgb(255, 0, 0);">&quot;w&quot;</span>, <span style="color: rgb(0, 0, 255);">stdout</span><span style="color: rgb(0, 128, 0);">)</span><span style="color: rgb(0, 128, 128);">;</span>
        <span style="color: rgb(0, 0, 221);">cin</span> <span style="color: rgb(0, 0, 128);">&gt;&gt;</span> n<span style="color: rgb(0, 128, 128);">;</span>
        <span style="color: rgb(0, 0, 255);">for</span><span style="color: rgb(0, 128, 0);">(</span><span style="color: rgb(0, 0, 255);">int</span> i <span style="color: rgb(0, 0, 128);">=</span> <span style="color: rgb(0, 0, 221);">1</span><span style="color: rgb(0, 128, 128);">;</span> i <span style="color: rgb(0, 0, 128);">&lt;=</span> n<span style="color: rgb(0, 128, 128);">;</span> i<span style="color: rgb(0, 0, 64);">++</span><span style="color: rgb(0, 128, 0);">)</span>
                <span style="color: rgb(0, 0, 255);">while</span><span style="color: rgb(0, 128, 0);">(</span><span style="color: rgb(0, 0, 221);">cin</span> <span style="color: rgb(0, 0, 128);">&gt;&gt;</span> m <span style="color: rgb(0, 0, 64);">&amp;&amp;</span> m<span style="color: rgb(0, 128, 0);">)</span>
                        EDGE<span style="color: rgb(0, 128, 0);">[</span>i<span style="color: rgb(0, 128, 0);">]</span> <span style="color: rgb(0, 0, 128);">=</span> <span style="color: rgb(0, 0, 221);">new</span><span style="color: rgb(0, 128, 0);">(</span><span style="color: rgb(0, 128, 0);">(</span><span style="color: rgb(0, 0, 255);">void</span> <span style="color: rgb(0, 0, 64);">*</span><span style="color: rgb(0, 128, 0);">)</span>tempedge<span style="color: rgb(0, 0, 64);">++</span><span style="color: rgb(0, 128, 0);">)</span> edge<span style="color: rgb(0, 128, 0);">(</span>i, m, EDGE<span style="color: rgb(0, 128, 0);">[</span>i<span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 128, 0);">)</span><span style="color: rgb(0, 128, 128);">;</span>
 
        <span style="color: rgb(0, 0, 255);">for</span><span style="color: rgb(0, 128, 0);">(</span><span style="color: rgb(0, 0, 255);">int</span> i <span style="color: rgb(0, 0, 128);">=</span> <span style="color: rgb(0, 0, 221);">1</span><span style="color: rgb(0, 128, 128);">;</span> i <span style="color: rgb(0, 0, 128);">&lt;=</span> n<span style="color: rgb(0, 128, 128);">;</span> i<span style="color: rgb(0, 0, 64);">++</span><span style="color: rgb(0, 128, 0);">)</span> <span style="color: rgb(102, 102, 102);">// tarjan's SCC</span>
                <span style="color: rgb(0, 0, 255);">if</span><span style="color: rgb(0, 128, 0);">(</span><span style="color: rgb(0, 0, 64);">!</span>DFN<span style="color: rgb(0, 128, 0);">[</span>i<span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 128, 0);">)</span>
                        tarjan<span style="color: rgb(0, 128, 0);">(</span>i<span style="color: rgb(0, 128, 0);">)</span><span style="color: rgb(0, 128, 128);">;</span>
        <span style="color: rgb(0, 0, 255);">for</span><span style="color: rgb(0, 128, 0);">(</span><span style="color: rgb(0, 0, 255);">int</span> j <span style="color: rgb(0, 0, 128);">=</span> <span style="color: rgb(0, 0, 221);">1</span><span style="color: rgb(0, 128, 128);">;</span> j <span style="color: rgb(0, 0, 128);">&lt;=</span> n<span style="color: rgb(0, 128, 128);">;</span> j<span style="color: rgb(0, 0, 64);">++</span><span style="color: rgb(0, 128, 0);">)</span>
                <span style="color: rgb(0, 0, 255);">for</span><span style="color: rgb(0, 128, 0);">(</span>edge <span style="color: rgb(0, 0, 64);">*</span>e <span style="color: rgb(0, 0, 128);">=</span> EDGE<span style="color: rgb(0, 128, 0);">[</span>j<span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 128, 128);">;</span> e<span style="color: rgb(0, 128, 128);">;</span> e <span style="color: rgb(0, 0, 128);">=</span> e<span style="color: rgb(0, 0, 64);">-</span><span style="color: rgb(0, 0, 128);">&gt;</span>next<span style="color: rgb(0, 128, 0);">)</span>
                        <span style="color: rgb(0, 0, 255);">if</span><span style="color: rgb(0, 128, 0);">(</span>SCC<span style="color: rgb(0, 128, 0);">[</span>e<span style="color: rgb(0, 0, 64);">-</span><span style="color: rgb(0, 0, 128);">&gt;</span>y<span style="color: rgb(0, 128, 0);">]</span> <span style="color: rgb(0, 0, 64);">!</span><span style="color: rgb(0, 0, 128);">=</span> SCC<span style="color: rgb(0, 128, 0);">[</span>j<span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 128, 0);">)</span>
                                dgr<span style="color: rgb(0, 128, 0);">[</span>SCC<span style="color: rgb(0, 128, 0);">[</span>e<span style="color: rgb(0, 0, 64);">-</span><span style="color: rgb(0, 0, 128);">&gt;</span>y<span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 128, 0);">[</span><span style="color: rgb(0, 0, 221);">0</span><span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 0, 64);">++</span>, dgr<span style="color: rgb(0, 128, 0);">[</span>SCC<span style="color: rgb(0, 128, 0);">[</span>j<span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 128, 0);">[</span><span style="color: rgb(0, 0, 221);">1</span><span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 0, 64);">++</span><span style="color: rgb(0, 128, 128);">;</span>
        <span style="color: rgb(0, 0, 255);">for</span><span style="color: rgb(0, 128, 0);">(</span><span style="color: rgb(0, 0, 255);">int</span> i <span style="color: rgb(0, 0, 128);">=</span> <span style="color: rgb(0, 0, 221);">1</span><span style="color: rgb(0, 128, 128);">;</span> count <span style="color: rgb(0, 0, 64);">!</span><span style="color: rgb(0, 0, 128);">=</span> <span style="color: rgb(0, 0, 221);">1</span> <span style="color: rgb(0, 0, 64);">&amp;&amp;</span> i <span style="color: rgb(0, 0, 128);">&lt;=</span> count<span style="color: rgb(0, 128, 128);">;</span> i<span style="color: rgb(0, 0, 64);">++</span><span style="color: rgb(0, 128, 0);">)</span> <span style="color: rgb(102, 102, 102);">// 只有一个强连通分量就不做累加</span>
                <span style="color: rgb(0, 128, 0);">(</span><span style="color: rgb(0, 0, 64);">!</span>dgr<span style="color: rgb(0, 128, 0);">[</span>i<span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 128, 0);">[</span><span style="color: rgb(0, 0, 221);">0</span><span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 128, 128);">?</span> dgr<span style="color: rgb(0, 128, 0);">[</span><span style="color: rgb(0, 0, 221);">0</span><span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 128, 0);">[</span><span style="color: rgb(0, 0, 221);">0</span><span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 0, 64);">++</span> <span style="color: rgb(0, 128, 128);">:</span> <span style="color: rgb(0, 0, 221);">0</span><span style="color: rgb(0, 128, 0);">)</span>, <span style="color: rgb(0, 128, 0);">(</span><span style="color: rgb(0, 0, 64);">!</span>dgr<span style="color: rgb(0, 128, 0);">[</span>i<span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 128, 0);">[</span><span style="color: rgb(0, 0, 221);">1</span><span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 128, 128);">?</span> dgr<span style="color: rgb(0, 128, 0);">[</span><span style="color: rgb(0, 0, 221);">0</span><span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 128, 0);">[</span><span style="color: rgb(0, 0, 221);">1</span><span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 0, 64);">++</span> <span style="color: rgb(0, 128, 128);">:</span> <span style="color: rgb(0, 0, 221);">0</span><span style="color: rgb(0, 128, 0);">)</span><span style="color: rgb(0, 128, 128);">;</span>
        <span style="color: rgb(0, 0, 221);">cout</span> <span style="color: rgb(0, 0, 128);">&lt;&lt;</span> <span style="color: rgb(0, 128, 0);">(</span>dgr<span style="color: rgb(0, 128, 0);">[</span><span style="color: rgb(0, 0, 221);">0</span><span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 128, 0);">[</span><span style="color: rgb(0, 0, 221);">0</span><span style="color: rgb(0, 128, 0);">]</span> <span style="color: rgb(0, 0, 128);">&gt;</span> <span style="color: rgb(0, 0, 221);">1</span> <span style="color: rgb(0, 128, 128);">?</span> dgr<span style="color: rgb(0, 128, 0);">[</span><span style="color: rgb(0, 0, 221);">0</span><span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 128, 0);">[</span><span style="color: rgb(0, 0, 221);">0</span><span style="color: rgb(0, 128, 0);">]</span> <span style="color: rgb(0, 128, 128);">:</span> <span style="color: rgb(0, 0, 221);">1</span><span style="color: rgb(0, 128, 0);">)</span> <span style="color: rgb(0, 0, 128);">&lt;&lt;</span> endl <span style="color: rgb(0, 0, 128);">&lt;&lt;</span> MAX<span style="color: rgb(0, 128, 0);">(</span>dgr<span style="color: rgb(0, 128, 0);">[</span><span style="color: rgb(0, 0, 221);">0</span><span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 128, 0);">[</span><span style="color: rgb(0, 0, 221);">0</span><span style="color: rgb(0, 128, 0);">]</span>, dgr<span style="color: rgb(0, 128, 0);">[</span><span style="color: rgb(0, 0, 221);">0</span><span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 128, 0);">[</span><span style="color: rgb(0, 0, 221);">1</span><span style="color: rgb(0, 128, 0);">]</span><span style="color: rgb(0, 128, 0);">)</span> <span style="color: rgb(0, 0, 128);">&lt;&lt;</span> endl<span style="color: rgb(0, 128, 128);">;</span>
        <span style="color: rgb(0, 0, 255);">return</span> <span style="color: rgb(0, 0, 221);">0</span><span style="color: rgb(0, 128, 128);">;
</span><span style="color: rgb(0, 128, 128); line-height: 12pt; text-indent: 0mm;">}</span></pre></div></div></div></div></div></div><div align="left" style="text-align: -webkit-left; text-indent: 0mm; margin: 4.75mm 0mm;"><font face="黑体"><font color="#010101"><span style="font-size: 13pt;"><b>[</b></span></font><font color="#010101"><span style="font-size: 13pt;"><b>注意事项</b></span></font><font color="#010101"><span style="font-size: 13pt;"><b>]</b></span></font></font></div><div align="left" style="text-align: -webkit-left; text-indent: 0mm; margin: 4.75mm 0mm;"><span style="color: rgb(1, 1, 1); text-indent: 0mm; font-family: 宋体;">1.一个是可能整个图是一个强连通分量，那么这个时候，整个图可以缩为一个点，这时候不需要添加额外的边。</span></div><div align="left" style="text-align: -webkit-left; text-indent: 0mm; margin: 4.75mm 0mm;"><div align="left" style="text-indent: 0mm; margin: 4.75mm 0mm;"><font color="#010101" face="宋体">2.递归时不要使用全局变量以减少代码行数为代价牺牲最基本的递归特性导致程序错误。</font></div></div><div align="justify"><font face="黑体"><font color="#010101"><span style="font-size: 13pt;"><b>[</b></span></font><font color="#010101"><span style="font-size: 13pt;"><b>难易等级</b></span></font><font color="#010101"><span style="font-size: 13pt;"><b>]</b></span></font></font><font color="#010101" size="2"><span style="font-size: 10pt;"><b><font face="黑体"> Medium Down(省选 the 1st)</font></b></span></font></div><div align="justify"><font color="#010101" face="Arial" style="text-align: -webkit-left; text-indent: 0mm;"><span style="font-size: 13pt;"><b><br></b></span></font></div><div align="justify"><font face="黑体"><b><font color="#010101" style="text-align: -webkit-left; text-indent: 0mm;"><span style="font-size: 13pt;">[其他分析</span></font><font color="#010101" style="text-align: -webkit-left; text-indent: 0mm;"><span style="font-size: 13pt;">]</span></font></b></font></div><div align="justify"><div align="left" style="text-indent: 0mm; text-align: -webkit-left; margin: 4.75mm 0mm;"><div style="text-align: start;font-size: 15px;"><p style="-webkit-hyphens: auto; margin-bottom: 1em; color: rgb(68, 68, 68); font-family: 'Helvetica Neue', Arial, Verdana, 'Hiragino Sans GB', STHeiti, SimSun, sans-serif; line-height: 22px; background-color: rgb(255, 255, 255);">该题描述的是一个有向图。我们都知道，在一个有向图强连通分量中从任意一个顶点开始，可以到达强连通分量的每个顶点。由此可以把该题中所有强连通分量收缩成分别一个顶点，则入度为0的顶点就是最少要接受新软件副本的学校。</p><p style="-webkit-hyphens: auto; margin-bottom: 1em; color: rgb(68, 68, 68); font-family: 'Helvetica Neue', Arial, Verdana, 'Hiragino Sans GB', STHeiti, SimSun, sans-serif; line-height: 22px; background-color: rgb(255, 255, 255);">第二问就是，问至少添加多少条边，才能使原图强连通。也就问在收缩后的图至少添加多少条边，才能使之强连通。</p><p style="-webkit-hyphens: auto; margin-bottom: 1em; color: rgb(68, 68, 68); font-family: 'Helvetica Neue', Arial, Verdana, 'Hiragino Sans GB', STHeiti, SimSun, sans-serif; line-height: 22px; background-color: rgb(255, 255, 255);">可以知道，当存在一个顶点入度为0或者出度为0的时候，该图一定不是强连通的。为了使添加的边最少，则应该把入度为0顶点和出度为0的顶点每个顶点添加1条边，使图中不存在入度为0顶点和出度为0的顶点。</p><p style="-webkit-hyphens: auto; margin-bottom: 1em; color: rgb(68, 68, 68); font-family: 'Helvetica Neue', Arial, Verdana, 'Hiragino Sans GB', STHeiti, SimSun, sans-serif; line-height: 22px; background-color: rgb(255, 255, 255);">当入度为0的顶点多于出度为0的顶点，则应添加的边数应为入度为0的顶点的个数。当出度为0的顶点多于出入度为0的顶点，则应添加的边数应为出度为0的顶点的个数。</p><p style="-webkit-hyphens: auto; margin-bottom: 1em; color: rgb(68, 68, 68); font-family: 'Helvetica Neue', Arial, Verdana, 'Hiragino Sans GB', STHeiti, SimSun, sans-serif; line-height: 22px; background-color: rgb(255, 255, 255);">这样就可以解决问题了。但是不要忘了还有特殊的情况，当原图本身就是强连通分量时，收缩成一个顶点，该顶点入度和出度都为0，但第一问应为1，第二问应为0。</p><p style="-webkit-hyphens: auto; margin-bottom: 1em; color: rgb(68, 68, 68); font-family: 'Helvetica Neue', Arial, Verdana, 'Hiragino Sans GB', STHeiti, SimSun, sans-serif; line-height: 22px; background-color: rgb(255, 255, 255);">求强连通分量，我用的两遍深搜的Kosaraju算法，时间复杂度为O(n)。把找到的每个强连通分量收缩为一的顶点，组成新图。设r(x)为x所在的强连同分量的代表节点，如果原图中存在边e(x,y)，那么新图中有边e(r(x),r(y)) 。然后根据点的邻接关系统计出度和入度即可。</p></div></div></div></div>
</div></body></html> 